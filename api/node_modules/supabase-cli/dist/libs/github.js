"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadGitHubFiles = exports.getGitHubFileList = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const promise_limit_1 = require("@node-libraries/promise-limit");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const getGitHubFileList = (repository, branch) => (0, cross_fetch_1.default)(`${repository}/find/${branch}`)
    .then((v) => v.text())
    .then((v) => v.match(/<virtual-filter-input[\s\S]*src="(.*)"/m)?.[1])
    .then((v) => v &&
    (0, cross_fetch_1.default)("https://github.com" + v, {
        headers: {
            accept: "application/json",
            "accept-encoding": "gzip, deflate, br",
        },
    })
        .then((v) => (v?.ok ? v.json() : undefined))
        .then((v) => v.paths))
    .catch(() => undefined);
exports.getGitHubFileList = getGitHubFileList;
const downloadGitHubFiles = async (repository, branch, src, outdir, options) => (0, exports.getGitHubFileList)(repository, branch).then(async (files) => {
    if (files) {
        const repo = repository.match(/https:\/\/github.com\/(.*)/)?.[1];
        const ps = (0, promise_limit_1.promiseLimit)();
        for (const file of files.filter((v) => v.startsWith(src))) {
            ps.add(async () => {
                const target = path_1.default.resolve(outdir, path_1.default.relative(src, file));
                if ((await options?.onDownload?.(file, target)) !== false) {
                    const value = await (0, cross_fetch_1.default)(`https://raw.githubusercontent.com/${repo}/${branch}/${file}`).then((v) => v.blob());
                    if (value) {
                        const targetDir = path_1.default.dirname(target);
                        if (target) {
                            await fs_1.promises
                                .mkdir(targetDir, { recursive: true })
                                .catch(() => undefined);
                            await fs_1.promises.writeFile(target, value.stream());
                        }
                    }
                }
            });
            await ps.wait(options?.parallels || 5);
        }
        await ps.all();
    }
});
exports.downloadGitHubFiles = downloadGitHubFiles;
